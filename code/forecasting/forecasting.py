# -*- coding: utf-8 -*-
"""Forecasting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ncz9NZ61Nod4kqKrltHXRyl7z-ahE94-
"""

#Open and serialize the data

with open("TME.csv") as f:
  content = f.readlines()
  print(content)
content = [x.strip() for x in content]

clean = [c.split(",") for c in content]

close = []
date = []
for i in clean[1:254]:
  close.append(float(i[4]))
  date.append(i[0])

closediff = []
for i in range(1,len(close)):
  closediff.append(close[i]-close[i-1])

with open("Future3.csv") as f1:
  content1 = f1.readlines()
  print(content1)
content1 = [x1.strip() for x1 in content1]
clean1 = [c1.split(",") for c1 in content1]

close1 = []
date1 = []
for i in clean1[1:-1]:
  close1.append(float(i[4]))
  date1.append(i[0])

closediff1 = []
for i in range(1,len(close1)):
  closediff1.append(close1[i]-close1[i-1])

import matplotlib.pyplot as plt
import numpy as np

len(close)

plt.plot(close)
plt.title("Tencent Closing Prices over 2021")
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.xlabel("Days")
plt.ylabel("Close Price")
plt.show

plt.plot(closediff)
plt.title("Tencent Closing Prices changes over 2021")
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.xlabel("Days")
plt.ylabel("Close Price Change")
plt.show

#define the forecasting functions

def expsmooth(data,a,n): #exponential smoothing
  lst = []
  lst.append(data[0])
  for i in range(len(data[1:-1])):
    lst.append(a*data[i+1]+(1-a)*lst[i])
  for m in range(n):
    lst.append(lst[-1])
  return lst

def MA(data,N,n): #moving average
  F = []
  for i in range(len(data)-N):
    D = []
    for j in range(N):
      D.append(data[i+j])
    F.append(sum(D)/N)
  for m in range(n):
    F.append(F[-1])
  return F

def WMA(data,N,n): #weighted moving average
  W = []
  WC = []
  F = []
  for i in range(N):
    W.append((i+1)*(1/N))
  scale = 1/sum(W)
  for j in W:
    WC.append(round(j*scale,3))
  for k in range(len(data)-N):
    D = []
    for l in range(len(WC)):
      D.append(data[k+l]*WC[l])
    F.append(sum(D))
  for m in range(n):
    F.append(F[-1])
  return F

def DMA(data,k,n): #double moving average
  M = WMA(data,k,0)
  P = WMA(M,k,0)
  S = []
  T = []
  F = []
  for t in range(len(P)):
    St=2*M[t]-P[t]
    Tt=(2*(M[t]-P[t]))/(k-1)
    S.append(St)
    T.append(Tt)
    F.append(St+Tt)
  for i in range(n):
    F.append(S[-1]+i*T[-1])
  #print("M",M)
  #print("P",P)
  #print("S",S)
  #print("T",T)
  #print("F",F)
  return F

#Error Measuring Functions

def MAD(d,f,n): #Mean Absolute Difference
  d1 = d[::-1]
  f1 = f[::-1]
  diff = []
  for i in range(len(f1)-n):
    diff.append(abs(f1[i+n]-d1[i]))
  E = sum(diff)/len(diff)
  return E

def MSE(d,f,n): #Mean square error
  d1 = d[::-1]
  f1 = f[::-1]
  diff = []
  for i in range(len(f1)-n):
    #print(d1[i],f1[i],(f1[i]-d1[i])**2)
    diff.append((f1[i+n]-d1[i])**2)
  E = sum(diff)/len(diff)
  return E

def ForeMAD(d,f): #MAD of the Forecast data *for changes in price
  d1 = d[::-1]
  f1 = f[::-1]
  diff = []
  for i in range(len(d1)):
    diff.append(abs(f1[i]-d1[i]))
  E = sum(diff)/len(diff)
  return E

def ForeMSE(d,f): #MSE of the Forecast Data *for changes in price
  d1 = d[::-1]
  f1 = f[::-1]
  diff = []
  for i in range(len(d1)):
    diff.append((f1[i]-d1[i])**2)
  E = sum(diff)/len(diff)
  return E

def ForeTMAD(d,f): #MAD of the Forecast data *for actual prices
  f1 = f[::-1]
  H = [d[0]]
  diff = []
  for j in range(len(d)):
    H.append(H[-1]+f1[j])
  for i in range(len(d)):
    diff.append(abs(H[i]-d[i]))
  E = sum(diff)/len(diff)
  return E

def ForeTMSE(d,f): #MSE of the Forecast data *for actual prices
  f1 = f[::-1]
  H = [d[0]]
  diff = []
  for j in range(len(d)):
    H.append(H[-1]+f1[j])
  for i in range(len(d)):
    diff.append((H[i]-d[i])**2)
  E = sum(diff)/len(diff)
  return E

def ForeTMAPE(d,f): #MAPE of the Forecast data *for actual prices
  f1 = f[::-1]
  H = [d[0]]
  diff = []
  for j in range(len(d)):
    H.append(H[-1]+f1[j])
  for i in range(len(d)):
    diff.append((abs(H[i]-d[i]))/d[i])
  MAPE = sum(diff)/len(diff)
  return MAPE

def MAEnum(data,future,N,n): #Create forecast for all windows sizes in list N
  MAlist = []
  MAMAD = {}
  MAMSE = {}
  FMAMAD = {}
  FMAMSE = {}
  FTMAMAD ={}
  FTMAMSE = {}
  for i in N:
    MAlist.append(MA(data,i,n))
  for j in range(len(MAlist)):
    MAMAD[N[j]]=MAD(data,MAlist[j],n)
    MAMSE[N[j]]=MSE(data,MAlist[j],n)
    FMAMAD[N[j]]=ForeMAD(future,MAlist[j])
    FMAMSE[N[j]]=ForeMSE(future,MAlist[j])
    FTMAMAD[N[j]]=ForeTMAD(close1,MAlist[j])
    FTMAMSE[N[j]]=ForeTMSE(close1,MAlist[j])
  return MAlist,MAMAD,MAMSE,FMAMAD,FMAMSE,FTMAMAD,FTMAMSE

def ExEnum(data,future,A,n): #Create forecast for all alpha in list n
  exp = []
  eMAD = {}
  eMSE = {}
  FeMAD = {}
  FeMSE = {}
  FTeMAD = {}
  FTeMSE = {}
  for i in A:
    exp.append(expsmooth(data,i,n))
  for j in range(len(exp)):
    eMAD[A[j]]=MAD(data,exp[j],n)
    eMSE[A[j]]=MSE(data,exp[j],n)
    FeMAD[A[j]]=ForeMAD(future,exp[j])
    FeMSE[A[j]]=ForeMSE(future,exp[j])
    FTeMAD[A[j]]=ForeTMAD(close1,exp[j])
    FTeMSE[A[j]]=ForeTMSE(close1,exp[j])
  return exp,eMAD,eMSE,FeMAD,FeMSE,FTeMAD,FTeMSE

def WMAEnum(data,future,N,n): #Create forecast for all windows sizes in list N
  WMAlist = []
  WMAMAD = {}
  WMAMSE = {}
  FWMAMAD = {}
  FWMAMSE = {}
  FTWMAMAD = {}
  FTWMAMSE = {}
  for i in N:
    WMAlist.append(WMA(data,i,n))
  for j in range(len(WMAlist)):
    WMAMAD[N[j]]=MAD(data,WMAlist[j],n)
    WMAMSE[N[j]]=MSE(data,WMAlist[j],n)
    FWMAMAD[N[j]]=ForeMAD(future,WMAlist[j])
    FWMAMSE[N[j]]=ForeMSE(future,WMAlist[j])
    FTWMAMAD[N[j]]=ForeTMAD(close1,WMAlist[j])
    FTWMAMSE[N[j]]=ForeTMSE(close1,WMAlist[j])
  return WMAlist,WMAMAD,WMAMSE,FWMAMAD,FWMAMSE,FTWMAMAD,FTWMAMSE

def DMAEnum(data,future,N,n): #Create forecast for all windows sizes in list N
  DMAlist = []
  DMAMAD = {}
  DMAMSE = {}
  DMAMAPE = {}
  FDMAMAD = {}
  FDMAMSE = {}
  FTDMAMAD = {}
  FTDMAMSE = {}
  for i in N:
    DMAlist.append(DMA(data,i,n))
  for j in range(len(DMAlist)):
    DMAMAD[N[j]]=round(MAD(data,DMAlist[j],n),3)
    DMAMSE[N[j]]=round(MSE(data,DMAlist[j],n),3)
    DMAMAPE[N[j]]=ForeTMAPE(close1,DMAlist[j])
    FDMAMAD[N[j]]=round(ForeMAD(future,DMAlist[j]),3)
    FDMAMSE[N[j]]=round(ForeMSE(future,DMAlist[j]),3)
    FTDMAMAD[N[j]]=ForeTMAD(close1,DMAlist[j])
    FTDMAMSE[N[j]]=ForeTMSE(close1,DMAlist[j])
  return DMAlist,DMAMAD,DMAMSE,DMAMAPE,FDMAMAD,FDMAMSE,FTDMAMAD,FTDMAMSE

def foreplot(fore,n): #Plots the actual prices and the forecast for jan 2022
  F =[]
  for i in fore:
    H =[close1[0]]
    for j in i[-n::]:
      H.append(H[-1]+j)
    F.append(H)
  plt.figure(figsize=(5,5))
  plt.plot(close1)
  for k in F:
    plt.plot(k)
  plt.title("Twitter Closing Prices Over 2021")
  plt.xticks(fontsize=10)
  plt.yticks(fontsize=10)
  plt.xlabel("Days")
  plt.ylabel("Close Price")
  plt.show

def foreplot1(data,data1,fore,n): #Plots the price changes for jan2021 - feb 2022 along with forecasts
  plt.figure(figsize=(10,10))
  plt.plot(data)
  for i in fore:
    x = len(data)-len(i)
    plt.plot(range(x+n,len(data)+n),i)
  plt.plot(range(len(data),len(data)+len(data1)),data1)
  plt.title("Twitter Closing Prices Over 2021")
  plt.xticks(fontsize=10)
  plt.yticks(fontsize=10)
  plt.xlabel("Days")
  plt.ylabel("Close Price")
  plt.axhline(0, color='black')
  plt.show

def foreplot2(data,fore,n): #plots just the price changes for 2021 and the forecasts
  plt.figure(figsize=(10,10))
  plt.plot(data)
  for i in range(len(fore)):
    x = len(data)-len(fore[i])
    plt.plot(range(x+n,len(data)+n),fore[i])
  plt.title("Twitter Closing Prices Over 2021 and forecast")
  plt.xticks(fontsize=10)
  plt.yticks(fontsize=10)
  plt.xlabel("Days")
  plt.ylabel("Close Price")
  plt.axhline(0, color='black')
  plt.show

def MPlot(dic): #plots the relationship between window size and error
  K = []
  V = []
  for k,v in dic.items():
    K.append(k)
    V.append(v)
  plt.figure(figsize=(3,3))
  plt.plot(K,V)
  plt.xlabel("Window Size")
  plt.ylabel("Error")
  vmin = np.argmin(V)
  kmin = K[vmin]
  print(kmin,min(V))

def GenN(start,stop):
  q=[]
  for i in range(start,stop):
    q.append(i)
  return q

def GenA(start,stop):
  q=[]
  for i in range(start,stop,1):
    q.append(i/100)
  return q

Base = closediff
Base1 = closediff1

A=GenA(4,7)
N = GenN(55,56)
n = 18
temp = [41,45]

MM,MMAD,MMSE,FMMAD,FMMSE,FTMMAD,FTMMSE = MAEnum(Base,Base1,N,n)
W,WMAD,WMSE,FWMAD,FWMSE,FTWMAD,FTWMSE = WMAEnum(Base,Base1,N,n)
D,DMAD,DMSE, DMAPE,FDMAD,FDMSE,FTDMAD,FTDMSE = DMAEnum(Base,Base1,N,n)
E,EMAD,EMSE,FEMAD,FEMSE,FTEMAD,FTEMSE = ExEnum(Base,Base1,A,n)

foreplot1(Base,Base1,D,n)
foreplot2(Base,D,n)
print("Main:",DMAD,DMSE)
print("Future:",FDMAD,FDMSE)
foreplot(D,n)

MPlot(DMAD)
MPlot(DMSE)
MPlot(DMAPE)
MPlot(FDMAD)
MPlot(FDMSE)
MPlot(FTDMAD)
MPlot(FTDMSE)

foreplot1(Base,Base1,MM,n)
print("Main:",MMAD,MMSE)
print("Future:",FMMAD,FMMSE)
foreplot(MM,n)

foreplot1(Base,Base1,W,n)
print("Main:",WMAD,WMSE)
print("Future:",FWMAD,FWMSE)
foreplot(W,n)

foreplot1(Base,Base1,E,n)
print("Main:",EMAD,EMSE)
print("Future:",FEMAD,FEMSE)
foreplot(E,n)

MPlot(MMAD)
MPlot(MMSE)
MPlot(FMMAD)
MPlot(FMMSE)
MPlot(FTMMAD)
MPlot(FTMMSE)

MPlot(WMAD)
MPlot(WMSE)
MPlot(FWMAD)
MPlot(FWMSE)
MPlot(FTWMAD)
MPlot(FTWMSE)

MPlot(EMAD)
MPlot(EMSE)
MPlot(FEMAD)
MPlot(FEMSE)
MPlot(FTEMAD)
MPlot(FTEMSE)

# METHOD 2 CODE MEAN REVERSION

# Parsing Data 
with open("TME.csv") as f:
  csv = f.readlines()
csv = [x.strip() for x in csv]

cleanedcsv = [c.split(",") for c in csv]

with open("Future3.csv") as f1:
  content1 = f1.readlines()
content1 = [x1.strip() for x1 in content1]
clean1 = [c1.split(",") for c1 in content1]
print(clean1)
cleanfut = []
for i in range(1,len(clean1)):
  cleanfut.append(float(clean1[i][4]))

# Model and Functions

closenums = []
date = []
x = 0
for i in cleanedcsv[198:252]:
  closenums.append(float(i[4]))
  date.append(x)
  x = x + 1
closediff1 = []
for i in range(0,len(closenums)-1):
  closediff1.append(closenums[i+1]-closenums[i])

def closestfinder(df, val, ind1, ind2): # ind 1 is the column you are searching through, and ind2 is the index of that column
  valslist = [100]
  indexlist = [0]
  for i in df.columns:
    if abs(df.iloc[ind1][i]-val) < min(valslist): # goes through each column, if that column has a value that is closer to the value defined than the original, it will add to the list
      valslist.append(abs(df.iloc[ind1][i])) # the value added to the list is an absolute of the difference
      indexlist.append(df.iloc[ind2][i]) # the index added is just the number associated with the value in the dataframe
  return indexlist[-1:][0]


changesafter = DataFrame({})
changesbefore = DataFrame({})
for i in range(0, len(closenums)-1):
  temp = []
  temp = [closenums[i], closenums[i+1] - closenums[i]]
  changesafter[i] = temp
  temp = [closenums[i], closenums[i]-closenums[i-1]]
  changesbefore[i] = temp

initval = [6.85]

def plotter():
  for i in range(0,10):
    initval.append(initval[i]+closestfinder(changesbefore, initval[i], 0, 1))
    i += 1
    initval.append(initval[i]+closestfinder(changesafter, initval[i], 0, 1))
  return initval
x = range(0,20)
y1 = plotter()[:20]
plt.plot(x, y1)
y2 = cleanfut
plt.plot(x, y2)
plt.show()

def MAPE(list1, list2):
  MAPE = []
  for i in range(len(list1)):
    MAPE.append(abs((list1[i]-list2[i])/list2[i]))
  return sum(MAPE)/len(MAPE)
def MAD(list1, list2):
  MAD = 0
  for i in range(len(list1)):
    MAD += abs(list1[i]-list2[i])/len(list1)
  return MAD
def MSE(list1, list2):
  MSE = 0
  for i in range(len(list1)):
    MSE += (list1[i]-list2[i])**2/len(list1)
  return MSE